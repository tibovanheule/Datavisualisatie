<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>

        .coeff .dot {
            fill: hsla(207, 63%, 27%, 0.2);
        }

        .coeff.last .dot {
            fill: hsla(207, 63%, 27%, 1.0);
        }

        .coeff .circle {
            fill: none;
            stroke: hsl(0, 0%, 70%);
        }

        .coeff.first .circle {
            fill: none;
            stroke: hsl(0, 0%, 30%);
        }

        .coeff.last .circle {
            display: none;
        }

        .graph {
            fill: none;
            stroke: steelblue;
            stroke-width: 3px;
        }

        .trace {
            fill: none;
            stroke: steelblue;
        }

        .proj {
            fill: none;
            stroke: #000;
        }

        .axis {
            stroke: hsl(0, 0%, 70%);
        }
    </style>
    <title>Fourrier</title>
    <link rel="apple-touch-icon" sizes="180x180" href="./images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./images/favicon-16x16.png">
    <link rel="manifest" href="./images/site.webmanifest">
    <link rel="shortcut icon" href="./images/favicon.ico">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-config" content="./images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
</head>
<body>
<script src="./js/d3.v6.js"></script>
<script>
    (function () {
        fetch("./data/result.json").then((d) => d.json()).then((data_r) => {
            let data_ = data_r.ori
            let pi = Math.PI
            let tweepi = 2 * Math.PI

            let get_coef = (n) => data_[n % data_.length] / 600;

            function FT(A, N, gamme) {
                gamme = gamme || 0;
                return function (x) {
                    let n = -1, y = 0;
                    while (++n < N) {
                        y += A[n] * Math.sin(tweepi * (n + 1) * x + gamme);
                    }
                    return y;
                }
            }

            let
                margin = {top: 40, right: 100, bottom: 40, left: 150},
                width = 960,
                height = 500,

                radius = 30,
                theta = 0,
                xmax = 1.5,
                rate = 1 / 60,// speed

                tDomain = d3.range(0, 1.1, 1 / 1000),   // trace domain
                gDomain = d3.range(0, xmax, xmax / 1000), // graph domain

                L = 50,            // size
                F = .3,          // frequence

                yCirc = d3.scaleLinear().domain([-1, 1]).range([height / 2 + radius, height / 2 - radius]),
                xCirc = d3.scaleLinear().domain([-1, 1]).range([0, 2 * radius]),
                rAxis = d3.scaleLinear().domain([0, 1]).range([0, radius]),
                xAxis = d3.scaleLinear().range([radius, width - margin.left]),

                Fxy, fx, fy,

                timer, data = [];

            let graph = d3.line()
                .x(function (d) {
                    return xAxis(d);
                })
                .y(function (d) {
                    return yCirc(fy(theta - d));
                });

            let proj = d3.line()
                .x(function (d) {
                    return xCirc(d.x);
                })
                .y(function (d) {
                    return yCirc(d.y);
                });

            let trace = d3.line()
                .x(function (d) {
                    return xCirc(fx(d));
                })
                .y(function (d) {
                    return yCirc(fy(d));
                });

            function gTransform(d) {
                return "translate(" + xCirc(d.x) + "," + yCirc(d.y) + ")";
            }

            function hTransform(d) {
                return "translate(" + xAxis(d.f) + "," + yCirc(0) + ")";
            }

            let svg = d3.select("body")
                .append("svg")
                .attr("viewBox", [0, 0, width, height + margin.top + margin.bottom])

            svg.append("line")
                .attr("class", "axis")
                .attr("y1", margin.top + yCirc(0)).attr("x1", 0)
                .attr("y2", margin.top + yCirc(0)).attr("x2", width);

            svg.append("line")
                .attr("class", "axis")
                .attr("x1", margin.left + xCirc(0)).attr("y1", 0)
                .attr("x2", margin.left + xCirc(0)).attr("y2", height);

            let vis = svg.append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            let gPath = vis.append("path").attr("class", "graph");
            let tPath = vis.append("path").attr("class", "trace");
            let pPath = vis.append("path").attr("class", "proj");

            function cache() {
                let A = d3.range(1, L + 1).map(get_coef);

                fx = FT(A, L - 1, pi / 2);
                fy = FT(A, L - 1, 0)
                Fxy = A.map(function (a, i) {
                    return {X: FT(A, i, pi / 2), Y: FT(A, i, 0), r: Math.abs(a)};
                });
            }

            function calc() {
                if (!Fxy) cache();
                Fxy.forEach(function (f, i) {
                    let d = data[i] || (data[i] = {x: 0, y: 0, r: 0});
                    d.x = f.X(theta);
                    d.y = f.Y(theta);
                    d.r = f.r;
                    d.f = i + 1;
                });
                data.length = Fxy.length;
                return data;
            }

            function coeff() {
                let co = vis.selectAll(".coeff").data(calc());

                // exit
                co.exit().remove();

                // enter
                let en = co.enter().append("g").attr("class", "coeff");

                en.append("circle").attr("class", "circle");
                en.append("circle").attr("class", "dot").attr("r", 3);

                // update
                co.classed("last", function (d, i) {
                    return i === L - 1;
                });
                co.classed("first", function (d, i) {
                    return i === 0;
                });

                co.select(".circle").attr("r", function (d) {
                    return rAxis(d.r);
                })

                return co;
            }

            function drawGraph() {
                xAxis.domain([0, xmax]);
                coeff().attr("transform", gTransform);
                let last = data[data.length - 1];
                pPath.attr("d", proj([last, {x: 0, y: last.y}]));
                gPath.attr("d", graph(gDomain));
                tPath.attr("d", trace(tDomain));
            }

            function play() {
                if (timer) return;
                (function loop() {
                    drawGraph();
                    theta += F * rate;
                    timer = setTimeout(loop, rate * 1000);
                })();
            }

            play();
        })


    })();
</script>
</body>
